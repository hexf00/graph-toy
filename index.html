<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>graph-toy</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

    <script src="https://cdn.staticfile.org/lodash.js/4.17.15/lodash.min.js"></script>
    <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.2.8/build/g6.js"></script>


    <script src="https://gw.alipayobjects.com/os/antv/assets/lib/jquery-3.2.1.min.js"></script>
    <script src="https://cdn.staticfile.org/moment.js/2.24.0/moment.js"></script>
    <script src="https://cdn.staticfile.org/moment.js/2.24.0/locale/zh-cn.js"></script>


    <script src="res/mark.js"></script>
    <script src="res/scheduler.js"></script>
    <script src="res/export.js"></script>
    <script src="res/import.js"></script>


    <!-- G6 behavior -->
    <script src="res/node-click.js"></script>
    <script src="res/custom-drag-node.js"></script>
    <script src="res/node-dblclick-edit.js"></script>
    <script src="res/shortcut-keys.js"></script>
    <script src="res/dblclick-new.js"></script>

    <link rel="stylesheet" href="https://cdn.staticfile.org/normalize/8.0.1/normalize.css">
    <link rel="stylesheet" href="res/css/reader.css">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
        }

        #mountNode {
            width: 100%;
            height: 100%;
        }

        #focus-input {
            outline: none;
            border: 1px solid rgb(24, 144, 255);
            position: absolute;
            width: auto;
            height: auto;
        }

        .file-handler {
            position: fixed;
            z-index: 999;
            top: 0;
        }

        .menu {
            position: fixed;
            display: none;
            z-index: 999;
            top: 0;
            background: rgb(219, 233, 240);
        }

        .menu ul {
            list-style: none;
            margin: 5px;
            padding: 0;
        }

        .attr-bar,
        .reader-bar,
        .left-bar {
            position: fixed;
            z-index: 999;
            top: 24px;
            padding: 5px;
            background: rgb(220, 221, 221);
            max-width: 300px;
            /* max-height: 200px; */
        }



        .reader-bar {
            /* top: 60px; */
            right: 250px;
            border: 1px solid rgb(165, 76, 76);
        }

        .reader-bar .content {
            max-height: 500px;
            overflow: auto;
        }

        .attr-bar {
            right: 0;
        }

        .search-bar ul,
        .attr-bar ul {
            list-style: none;
            margin: 5px;
            padding: 0;
            max-height: 200px;
            overflow: auto;

        }

        .search-bar ul li {
            /*超出部分隐藏*/
            overflow: hidden;
            /* 超出部分显示省略号 */
            text-overflow: ellipsis;
            /*规定段落中的文本不进行换行 */
            white-space: nowrap;
        }

        .highlight {
            font-weight: bold;
            color: rgb(255, 255, 60);
        }

        ul.tab-title {
            margin: 0;
            padding: 0;
        }

        ul.tab-title li {
            display: inline-block;
            cursor: pointer;
        }

        ul.tab-title li.active {
            font-weight: bold;
        }
    </style>


</head>

<body>
    <div id="app">
        <div class="file-handler">
            <button onclick="$('#fileSelect').click()">导入</button>
            <input type="file" onchange="importData(this)" name="" id="fileSelect" style="width:0px;height:1px;">

            <button onclick="exportData()">导出</button>

            <span>自动保存状态:{{saveTimeShowText}}</span>
        </div>
        <div v-if="!showSearch" class="left-bar" @click="showSearch=true">+</div>
        <div v-else class="tab left-bar">
            <ul class="tab-title">
                <li :class="{active: activeTabIndex == 0}" @click="activeTab(0)">节点</li>
                /
                <li :class="{active: activeTabIndex == 1}" @click="activeTab(1)">类型</li>
                <span style="float: right;" @click="showSearch=false">x</span>
            </ul>
            <div class="tab-content">
                <div v-show="activeTabIndex == 0" class="search-bar">
                    <div>
                        <input type="text" v-model="filterKey">
                    </div>

                    <ul>
                        <li v-for="node in listNodes" :title="node.label" :data-id="node.id"
                            @click="focus($event.target)">
                            {{node.label}}
                        </li>
                    </ul>
                </div>
                <div v-show="activeTabIndex == 1">

                    <ul>
                        <li v-for="category in categories" :title="category.label" :data-category="category.label"
                            @click="searchCategory($event.target)">
                            {{category.label}} {{category.count}}
                        </li>
                    </ul>
                </div>
            </div>
        </div>



        <div class="attr-bar">
            <div v-if="!showAttr" @click="showAttr=true">+</div>

            <div v-else>
                <div><span style="float: right;" @click="showAttr=false">x</span></div>
                <div>
                    <p v-if="currentType == 'Node'">
                        currentType:{{currentType}}
                    </p>
                    <p v-else>
                        {{currentEdgeSource}} =={{currentItem.label}}==>
                        {{currentEdgeTarget}}
                    </p>
                    <p>label：<input type="text" v-model="currentItem.label" name="label"></p>
                    <p v-if="currentType == 'Node'">分类：<input type="text" v-model="currentItem.category"
                            name="category"></p>
                    <div>
                        <div>描述:</div>
                        <textarea style="width: 98%;min-height: 80px;" type="text" v-model="currentItem.description"
                            name="description"></textarea>
                    </div>
                    <button type="button" @click="updateItem()">保存</button>
                </div>
            </div>

        </div>

        <div v-if="!showReader" class="reader-bar">
            <div @click="showReader=true">+</div>
        </div>
        <div v-else class="reader-bar">
            <div>
                <button @click="createSelectedTextNode">选中文字创建节点</button>

                <button onclick="$('#articleSelect').click()">导入文字</button>
                <input type="file" onchange="importArticle(this)" name="" id="articleSelect"
                    style="width:0px;height:1px;">

                <span style="float: right;" @click="showReader=false">x</span>
            </div>
            <div id="content" class="content" @mouseup="getSelection"></div>
        </div>

    </div>

    <div class="menu">
        <ul>
            <li><a href="javascript:;" onclick="rule_selected(this)">选中一级节点</a></li>
            <li><a href="javascript:;" onclick="relayout(this)">重新布局</a></li>
        </ul>
    </div>
    <div style="position:absolute;width:100%;height:100%;overflow-y: hidden;">

        <div id="mountNode"></div>
        <div type="text" id="focus-input"></div>

    </div>
    <script type="text/javascript" language=JavaScript charset="UTF-8">
        var ControlStatus = false;
        document.onkeydown = function (event) {
            var e = event || window.event || arguments.callee.caller.arguments[0];
            if (e && e.key == 'Control') { // 按 Esc 
                //要做的事情
                ControlStatus = true;
            }
        };
        document.onkeyup = function (event) {
            var e = event || window.event || arguments.callee.caller.arguments[0];
            if (e && e.key == 'Control') { // 按 Esc 
                //要做的事情
                ControlStatus = false;
            }
        }; 
    </script>
    <script>
        //光标最后 cnblogs.com/ybixian/p/10601224.html
        function keepLastIndex(obj) {
            // console.log(obj)
            // console.log(window.getSelection)
            // console.log(document.selection)
            if (window.getSelection) { //ie11 10 9 ff safari
                obj.focus(); //解决ff不获取焦点无法定位问题
                var range = window.getSelection(); //创建range
                range.selectAllChildren(obj); //range 选择obj下所有子内容
                range.collapseToEnd(); //光标移至最后
            } else if (document.selection) { //ie10 9 8 7 6 5
                var range = document.selection.createRange(); //创建选择对象
                //var range = document.body.createTextRange();
                range.moveToElementText(obj); //range定位到obj
                range.collapse(false); //光标移至最后
                range.select();
            }
        }

        //载入缓存
        localStorage.setItem("auto-save-data-key", "auto-save-data");
        var data = { "nodes": [], "edges": [] }
        try {
            var key = localStorage.getItem("auto-save-data-key");
            var rawData = localStorage.getItem(key);
            if (key && rawData) {
                data = JSON.parse(rawData);
            }
        } catch (e) {
            console.error(e);
        }


        //needAutoSaveStatus 用来判断是否需要保存
        var needAutoSaveStatus = false;
        setInterval(function () {
            if (needAutoSaveStatus) {

                console.log("触发自动保存");
                // localStorage.setItem();

                var root = graph.save().nodes[0].label;
                var saveIndexData = [];

                var key = localStorage.getItem("auto-save-data-key");
                localStorage.setItem(key, JSON.stringify(graph.save()));
                exportData(); //调用下载自动保存

                app.saveTime = new Date();

                needAutoSaveStatus = false; //更新保存状态
            }
        }, 5000); //5s尝试保存一次


        //1s更新显示保存时间
        setInterval(function () {
            if (app) {
                if (app.saveTime) {
                    if (moment().diff(app.saveTime, 'seconds') < 44) {
                        app.saveTimeShowText = moment().diff(app.saveTime, 'seconds') + "秒前";
                    } else {
                        app.saveTimeShowText = moment(app.saveTime).fromNow();

                    }
                }
            }
        }, 1000)

        data.edges = data.edges.map((edge) => {
            edge.style.endArrow = true
            // edge.style.startArrow = true
            return edge
        })
        console.log(JSON.stringify(data.edges));



        G6.registerBehavior('edgeClick', {
            getEvents() {
                return {
                    'edge:click': 'onClick',
                };
            },
            onClick(e) {
                e.preventDefault();
                if (!this.shouldUpdate.call(this, e)) {
                    return;
                }
                const { item } = e;
                const graph = this.graph;

                console.log(e, item);


                // if (!ControlStatus) {
                //     //关闭多选
                //     const selectedNodes = graph.findAllByState('node', 'selected');
                //     selectedNodes.forEach(cn => {
                //         graph.setItemState(cn, 'selected', false);
                //     });
                // }

                // graph.setItemState(item, 'selected', true);
            },
        });






        const graph = new G6.Graph({
            container: 'mountNode',  // String | HTMLElement，必须，容器 id 或容器本身
            width: Math.floor($('#mountNode').width()),              // Number，必须，图的宽度
            height: Math.floor($('#mountNode').height()),             // Number，必须，图的高度
            // renderer: "svg",
            modes: {
                default: [
                    'dblclick-new',
                    'shortcut-keys',
                    'edgeClick',
                    'brush-select',
                    'custom-drag-node',
                    'node-dblclick-edit',
                    'node-click',
                    'drag-canvas',
                    'zoom-canvas'
                ]
            },
            defaultEdge: {
                style: {
                    endArrow: true,
                    lineWidth: 3
                }
            },
            nodeStateStyles: {
                selected: {
                    // hover 状态为 true 时的样式
                    fill: '#d3adf7',
                },
            },
            // layout: {
            //     type: 'force',            // 设置布局算法为 force
            //     linkDistance: 150,        // 设置边长为 100
            //     preventOverlap: true,     // 设置防止重叠
            //     nodeSize: 60,
            //     nodeStrength: 10,
            //     edgeStrength: 3,
            // },  

            // 边在各状态下的样式
            edgeStateStyles: {
                hover: {
                    stroke: '#f00'
                },
                // click 状态为 true 时的样式
                selected: {
                    stroke: '#f00'
                }
            },

            animate: true            // Boolean，可选，切换布局时是否使用动画过度
        });

        // 监听鼠标进入节点
        graph.on('node:mouseenter', e => {
            const nodeItem = e.item;
            // 设置目标节点的 hover 状态 为 true
            graph.setItemState(nodeItem, 'hover', true);
        });
        // 监听鼠标离开节点
        graph.on('node:mouseleave', e => {
            const nodeItem = e.item;
            // 设置目标节点的 hover 状态 false
            graph.setItemState(nodeItem, 'hover', false);
        });
        // 监听鼠标进入节点
        graph.on('edge:mouseenter', e => {
            const nodeItem = e.item;
            // 设置目标节点的 hover 状态 为 true
            graph.setItemState(nodeItem, 'hover', true);
        });
        // 监听鼠标离开节点
        graph.on('edge:mouseleave', e => {
            const nodeItem = e.item;
            // 设置目标节点的 hover 状态 false
            graph.setItemState(nodeItem, 'hover', false);
        });

        // 监听鼠标点击边
        graph.on('edge:click', e => {
            // 先将所有当前有 click 状态的边的 click 状态置为 false
            const clickEdges = graph.findAllByState('edge', 'selected');
            clickEdges.forEach(ce => {
                graph.setItemState(ce, 'selected', false);
            });
            const edgeItem = e.item;
            // 设置目标边的 click 状态 为 true
            graph.setItemState(edgeItem, 'selected', true);


            app.currentType = "Edge";
            app.currentItem = edgeItem.getModel();
        });

        //参考antv-2018.alipay.com/zh-cn/g6/3.x/demo/tool/context-menu.html
        graph.on('node:contextmenu', function (evt) {
            console.log();
            $('.menu').css('left', evt.clientX).css('top', evt.clientY).show();


            //设置ID 便于后续操作
            $('.menu a').data('id', evt.item.getModel().id);
        });

        graph.on('node:mouseleave', function (evt) {
            $('.menu').hide();
        });

        // 读取数据和渲染
        graph.data(data);
        graph.render();

        var graphUpdate = _.throttle(function (event, args) {
            console.log("graphUpdate 触发");
            needAutoSaveStatus = true; //需要保存
            app.$set(app.graphData, 'nodes', graph.save().nodes);
        }, 100, {
            leading: false,
            trailing: true //节流结束后执行
        })

        graph.on("afteradditem", function () { graphUpdate.call(this, 'afteradditem', arguments) })
        graph.on("afterremoveitem", function () { graphUpdate.call(this, 'afterremoveitem', arguments) })
        graph.on("afterupdateitem", function () { graphUpdate.call(this, 'afterupdateitem', arguments) })
    </script>

    <script>


        function relayout(el) {
            var currentNodeId = $(el).data('id');
            var node = graph.findById(currentNodeId);
            // console.log();
            subLayout(node.getModel());
        }
        // 参考g6.antv.vision/zh/examples/net/layoutMechanism#subgraphLayout
        // yuque.com/antv/g6/qopkkg#eYZc6
        function subLayout(centerNode) {

            const data = graph.save(); //最新数据




            const nodes = data.nodes;
            const edges = data.edges;

            const newNodes = []; //被用来参加子图布局计算的节点
            const newEdges = [];
            const newNodeMap = new Map(); //

            //这句不懂 暂时保留
            // fix the nodes[0]
            // nodes[0].fx = nodes[0].x;
            // nodes[0].fy = nodes[0].y;


            //获取选择中的节点

            console.log()

            graph.findAllByState('node', 'selected').forEach(function (node, i) {
                var nodeModel = node.getModel();
                // nodeModel.fx = nodeModel.x;
                // nodeModel.fy = nodeModel.y;

                // nodeModel.x = null;
                // nodeModel.y = null;
                newNodes.push(nodeModel);
                newNodeMap.set(node.getModel().id, i);
            });


            // add the nodes which should be re-layout
            // nodes



            console.log(newNodes, newNodeMap);

            // add related edges
            // 只要有关系都带进来
            edges.forEach(function (edge) {
                const sourceId = edge.source;
                const targetId = edge.target;
                if (newNodeMap.get(sourceId) !== undefined && newNodeMap.get(targetId) !== undefined) {
                    newEdges.push(edge);
                }
            });

            const subForceLayout = new G6.Layout.force({
                center: [centerNode.x, centerNode.y],
                linkDistance: 120,
                preventOverlap: true,
                // nodeSize: 20,
                tick: function tick() {
                    // the tick function to show the animation of layout process
                    graph.refreshPositions();
                }
            });

            //下面布局算法需要手动调用graph.refreshPositions();

            // const subForceLayout = new G6.Layout.radial({
            //     center: [centerNode.x,centerNode.y],
            //     unitRadius: 120,
            //     preventOverlap:false,
            //     nodeSize:200,
            //     nodeSpacing:50,

            // });


            // dagre算法没有中心节点参数指定
            // const subForceLayout = new G6.Layout.dagre({
            //     nodeSize: [40, 20],
            //     nodesep: 1,
            //     ranksep: 1
            // });




            subForceLayout.init({
                nodes: newNodes,
                edges: newEdges
            });
            subForceLayout.execute();

        }


        rule_selected = function (el) {
            var currentNodeId = $(el).data('id');

            //选择该节点的指向节点
            graph.getEdges().forEach(edge => {
                const sourceId = edge.getModel().source;
                const targetId = edge.getModel().target;

                if (sourceId === currentNodeId) {
                    graph.setItemState(targetId, 'selected', true);
                }
            })
        }
    </script>

    <script>
        //代码参考cn.vuejs.org/v2/examples/grid-component.html
        var app = new Vue({
            el: '#app',
            computed: {
                currentEdgeSource: function () {
                    if (this.currentType == "Edge") {
                        return graph.findById(this.currentItem.source).getModel().label
                    }
                },
                currentEdgeTarget() {
                    if (this.currentType == "Edge") {
                        return graph.findById(this.currentItem.target).getModel().label
                    }
                },
                categories() {
                    var categoriesMap = {};

                    // 需要理解computed的原理，推测只要有JSON.stringify的调用就会强制调用，其它情况会根据引用决定
                    //    console.log(JSON.stringify(  graph.save().nodes));

                    this.graphData.nodes.forEach(it => {
                        if (it.category) {
                            if (categoriesMap[it.category] === undefined) {
                                categoriesMap[it.category] = 1
                            } else {
                                categoriesMap[it.category]++
                            }
                        } else {
                            var key = "none";
                            if (categoriesMap[key] === undefined) {
                                categoriesMap[key] = 1
                            } else {
                                categoriesMap[key]++
                            }
                        }
                    });

                    var categories = [];
                    for (var k in categoriesMap) {
                        categories.push({
                            label: k,
                            count: categoriesMap[k]
                        })
                    }
                    return categories;
                },
                listNodes: function () {
                    // console.log("listNodes 更新", JSON.stringify(this.graphData.nodes))
                    // var sortKey = this.sortKey
                    var filterKey = this.filterKey && this.filterKey.toLowerCase()


                    // var order = this.sortOrders[sortKey] || 1
                    var nodes = this.graphData.nodes
                    if (filterKey) {
                        nodes = nodes.filter(function (row) {

                            // console.log(filterKey.)
                            var start = filterKey.indexOf("c:");
                            if (start !== -1) {
                                var filterVal = filterKey.slice(start + 2);

                                if (filterVal == "") {
                                    return true //全部
                                } else if (filterVal == "none") {
                                    return !row.category
                                } else {
                                    return row.category && row.category.toLowerCase().indexOf(filterVal) > -1;
                                }
                            } else {
                                return Object.keys(row).some(function (key) {
                                    return String(row[key]).toLowerCase().indexOf(filterKey) > -1
                                })
                            }
                        })
                    }
                    // if (sortKey) {
                    //     nodes = nodes.slice().sort(function (a, b) {
                    //         a = a[sortKey]
                    //         b = b[sortKey]
                    //         return (a === b ? 0 : a > b ? 1 : -1) * order
                    //     })
                    // }
                    return nodes
                },

            },
            methods: {
                activeTab: function (index) {
                    this.activeTabIndex = index;
                },
                updateItem: function () {

                    if (this.currentType == "Node") {

                        var item = graph.findById(this.currentItem.id);
                        //item.update 不会触发g6事件 改为 graph.updateItem
                        graph.updateItem(item, {
                            // id: this.currentItem.id,
                            description: this.currentItem.description,
                            category: this.currentItem.category,
                            label: this.currentItem.label
                        })

                        graph.refreshItem(item)
                    } else {
                        var item = graph.findById(this.currentItem.source);
                        const edges = item.getOutEdges()

                        edges.forEach(edge => {
                            if (edge.getModel().target == this.currentItem.target) {
                                edge.update({
                                    // id: this.currentItem.id,
                                    description: this.currentItem.description,
                                    label: this.currentItem.label
                                });

                                graph.refreshItem(edge)
                            }

                        })

                    }

                },
                getSelection() {




                },
                createSelectedTextNode: function () {
                    if (window.getSelection().toString() == "") {
                        return;
                    }
                    const nodes = graph.findAllByState('node', 'selected');
                    var id = new Date().getTime() + parseInt(Math.random() * 1000).toString();

                    //因为需要手动指定x,y 无法调用布局方法
                    var x = 0, y = 0;
                    if (nodes.length) {
                        x = nodes[0].getModel().x + 100;
                        y = nodes[0].getModel().y;
                    }
                    graph.addItem('node', {
                        id: id,
                        realId: id,
                        label: window.getSelection().toString(),
                        x: x,
                        y: y
                    })

                    if (nodes.length) {
                        graph.addItem('edge', {
                            source: nodes[0].getModel().id,
                            target: id
                        });
                    }

                    // 使用changeData也许要传递xy,如果不传递调用2次后
                    //检测到有节点没有x\y 会导致重新布局 已有位置信息全部丢失

                    //原文标注
                    var html = $("#content").html();
                    // html = html.replace(
                    //     new RegExp(window.getSelection().toString(), 'g'),
                    //     `<span class="highlight" data-id="${id}" onclick="app.focus(this)">${window.getSelection().toString()}</span>`
                    // )

                    html = mark(html,
                        new RegExp(window.getSelection().toString(), 'g'),
                        {
                            html: `<span class="highlight" data-id="${id}" onclick="app.focus(this)">${window.getSelection().toString()}</span>`,
                        }
                    );

                    $("#content").html(html);

                },
                renderReader() {
                    //渲染标注文本
                    var html = localStorage.getItem('reader-text');
                    // console.log(html);
                    var nodes = graph.save().nodes;

                    nodes = nodes.sort((a,b)=>{
                        return b.label.length - a.label.length
                    })

                    for (var node of nodes) {
                        var { id, label } = node;
                        if(!label){
                            continue;
                        }
                        try {
                            
                            html = html.replace(
                                new RegExp(label, 'g'),
                                `<span class="highlight" data-id="${id}" onclick="app.focus(this)">${label}</span>`
                            )

                            //mark函数存在非常严重的bug

                            // html = mark(html,
                            //     new RegExp(label
                            //         // .replace(/\//g, "\\\/")
                            //         // .replace(/\@/g, "\\\@")
                            //         , 'g'),
                            //     {
                            //         html: `<span class="highlight" data-id="${id}" onclick="app.focus(this)">${label}</span>`,
                            //     }
                            // );
                        } catch (error) {
                            console.error(error)
                        }

                    }
                    $("#content").html(html);

                },
                searchCategory(target) {
                    this.activeTabIndex = 0;
                    var { category } = target.dataset;
                    this.filterKey = "c:" + category;
                },
                focus: function (target) {
                    console.log(target, this);

                    //参考g6.antv.vision/zh/examples/interaction/position
                    var { id } = target.dataset;

                    var item = graph.findById(id);

                    const selectedNodes = graph.findAllByState('node', 'selected');
                    selectedNodes.forEach(cn => {
                        graph.setItemState(cn, 'selected', false);
                    });


                    graph.setItemState(item, 'selected', true);

                    this.currentType = "Node";
                    this.currentItem = item.getModel();
                    // const item = event.item;
                    // 聚焦当前点击的节点（把节点放到视口中心）

                    const matrix = item.get('group').getMatrix();
                    const point = {
                        x: matrix[6],
                        y: matrix[7]
                    };
                    const width = graph.get('width');
                    const height = graph.get('height');
                    // 找到视口中心
                    const viewCenter = {
                        x: width / 2,
                        y: height / 2
                    };
                    const modelCenter = graph.getPointByCanvas(viewCenter.x, viewCenter.y);
                    const viewportMatrix = graph.get('group').getMatrix();
                    // 画布平移的目标位置，最终目标是graph.translate(dx, dy);
                    const dx = (modelCenter.x - point.x) * viewportMatrix[0];
                    const dy = (modelCenter.y - point.y) * viewportMatrix[4];
                    let lastX = 0;
                    let lastY = 0;
                    let newX = void 0;
                    let newY = void 0;
                    // 动画每次平移一点，直到目标位置
                    graph.get('canvas').animate({
                        onFrame: function onFrame(ratio) {
                            newX = dx * ratio;
                            newY = dy * ratio;
                            graph.translate(newX - lastX, newY - lastY);
                            lastX = newX;
                            lastY = newY;
                        }
                    }, 300, 'easeCubic');

                    console.log(this, id)
                }
            },
            created() {
                this.renderReader();
            },
            data: {
                currentType: '', //Node、Edge
                currentItem: {},
                activeTabIndex: 0,
                showReader: true,
                showSearch: true,
                showAttr: true,
                filterKey: "",
                saveTime: "", //自动保存时间
                saveTimeShowText: "无", //保存时间显示
                graphData: graph.save(),
                // nodes: graph.save().nodes,
            }
        })

    </script>
</body>

</html>