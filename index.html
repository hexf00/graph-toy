<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>graph-toy</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

    <script src="https://cdn.staticfile.org/lodash.js/4.17.15/lodash.min.js"></script>
    <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.2.9/build/g6.js"></script>


    <script src="https://gw.alipayobjects.com/os/antv/assets/lib/jquery-3.2.1.min.js"></script>
    <script src="https://cdn.staticfile.org/moment.js/2.24.0/moment.js"></script>
    <script src="https://cdn.staticfile.org/moment.js/2.24.0/locale/zh-cn.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uuid@7.0.0-beta.0/dist/umd/uuidv4.min.js"></script>


    <!-- func -->
    <script src="res/mark.js"></script>
    <script src="res/libs/Scheduler.js"></script>
    <script src="res/export.js"></script>
    <script src="res/import.js"></script>
    <script src="res/data-check.js"></script>
    <script src="res/data-layer.js"></script>


    <!-- G6 behavior -->
    <script src="res/g6-behaviors/node-click.js"></script>
    <script src="res/g6-behaviors/custom-drag-node.js"></script>
    <script src="res/g6-behaviors/shortcut-keys.js"></script>
    <script src="res/g6-behaviors/dblclick-new.js"></script>

    <!-- vue -->
    <script src="res/component/set-category.js"></script>
    <script src="res/component/node-detail.js"></script>
    <script src="res/component/tab/tab.js"></script>
    <script src="res/component/tab/panel.js"></script>

    <link rel="stylesheet" href="https://cdn.staticfile.org/normalize/8.0.1/normalize.css">
    <link rel="stylesheet" href="res/css/reader.css">
    <link rel="stylesheet" href="res/css/style.css">
</head>

<body>
    <div id="app">
        <div class="file-handler">
            <button onclick="$('#fileSelect').click()">导入</button>
            <input type="file" onchange="importData(this)" name="" id="fileSelect" style="width:0px;height:1px;">

            <button onclick="exportData()">导出</button>

            <set-category></set-category>
            <button onclick="hide()">隐藏边</button>
            <button @click="showCategory(!showCategoryStatus)"> {{ showCategoryStatus ? "隐藏" : "显示"}}分类</button>
            <span>自动保存状态:{{saveTimeShowText}}</span>
        </div>
        <div v-if="!showSearch" class="left-bar" @click="showSearch=true">+</div>
        <div v-else class="tab left-bar">
            <span style="float: right;" @click="showSearch=false">x</span>
            <tab v-model="leftTabActive">
                <panel title="节点" class="search-bar">
                    <div>
                        <input type="text" v-model="filterKey">
                        <span title="找到节点数">{{listNodes.length}}</span>
                    </div>

                    <ul>
                        <li v-for="node in listNodes" :title="node.label" :data-id="node.id"
                            @click="focus($event.target)">
                            {{node.label}}
                        </li>
                    </ul>
                </panel>
                <panel title="类型" class="search-bar">
                    <ul>
                        <li v-for="category in categories" :title="category.label" :data-category="category.label"
                            @click="searchCategory($event.target)">
                            {{category.label}} {{category.count}}
                        </li>
                    </ul>
                </panel>
            </tab>
        </div>



        <div class="attr-bar">
            <div v-if="!showAttr" @click="showAttr=true">+</div>

            <div v-else>
                <div><span style="float: right;" @click="showAttr=false">x</span></div>
                <tab v-model="rightTabActve">
                    <panel title="属性">
                        <p v-if="currentType == 'Node'">
                            currentType:{{currentType}}
                        </p>
                        <p v-else>
                            {{currentEdgeSource}} =={{currentItem.label}}==>
                            {{currentEdgeTarget}}
                        </p>
                        <p>label：<input type="text" v-model="currentItem.label" name="label"></p>
                        <p v-if="currentType == 'Node'">分类：<input type="text" v-model="currentItem.category"
                                name="category"></p>
                        <p v-if="currentType == 'Node'">类型：
                            <select v-model="currentItem.type">
                                <option value="">无</option>
                                <option value="word">词语</option>
                                <option value="entity">实体</option>
                                <option value="class">类</option>
                            </select>
                        </p>
                        <div>
                            <div>描述:</div>
                            <textarea style="width: 98%;min-height: 150px;" type="text"
                                v-model="currentItem.description" name="description"></textarea>
                        </div>
                        <button type="button" @click="updateItem()">保存</button>
                        <ul v-if="currentType == 'Node'">
                            <li v-for="edge in currentItemEdges">
                                <input type="checkbox" @click="changeEdgeVisible(edge, $event.target.checked)"
                                    :checked="edge.visible !== false" />
                                <span :class="{strong:currentItem.id !== edge.source}" :data-id="edge.source"
                                    :title="edge.sourceModel.category"
                                    @click="focus($event.target)">{{edge.sourceModel.label}}</span>
                                <span>=={{edge.label}}==></span>
                                <span :class="{strong:currentItem.id !== edge.target}" :data-id="edge.target"
                                    :title="edge.sourceModel.category"
                                    @click="focus($event.target)">{{edge.targetModel.label}}</span>
                            </li>
                        </ul>
                    </panel>
                    <panel title="JSON">
                        <pre v-html="JSON.stringify(currentItem,null,2)"></pre>
                    </panel>
                </tab>
            </div>

        </div>

        <div v-if="!showReader" class="reader-bar">
            <div @click="showReader=true">+</div>
        </div>
        <div v-else class="reader-bar">
            <div>
                <button @click="createSelectedTextNode">选中文字创建节点</button>

                <button onclick="$('#articleSelect').click()">导入文字</button>
                <input type="file" onchange="importArticle(this)" name="" id="articleSelect"
                    style="width:0px;height:1px;">

                <span style="float: right;" @click="showReader=false">x</span>
            </div>
            <div id="content" ref="readerContent" class="content" @scroll="readerScroll" @mouseup="getSelection"
                v-html="contentHtml"></div>
        </div>
        <node-detail :node="hoverNode" :x="hoverX" :y="hoverY"></node-detail>
    </div>

    <div class="menu">
        <ul>
            <li><a href="javascript:;" onclick="rule_selected(this)">选中一级节点</a></li>
            <li><a href="javascript:;" onclick="relayout(this)">重新布局</a></li>
        </ul>
    </div>
    <div style="position:absolute;width:100%;height:100%;overflow-y: hidden;">

        <div id="mountNode"></div>
        <div type="text" id="focus-input"></div>

    </div>
    <script type="text/javascript" language=JavaScript charset="UTF-8">
        var ControlStatus = false;
        document.onkeydown = function (event) {
            var e = event || window.event || arguments.callee.caller.arguments[0];
            if (e && e.key == 'Control') { // 按 Esc 
                //要做的事情
                ControlStatus = true;
            }
        };
        document.onkeyup = function (event) {
            var e = event || window.event || arguments.callee.caller.arguments[0];
            if (e && e.key == 'Control') { // 按 Esc 
                //要做的事情
                ControlStatus = false;
            }
        }; 
    </script>
    <script>
        //载入缓存

        var data = { "nodes": [], "edges": [] }
        try {
            var rawData = localStorage.getItem("auto-save-data");
            if (rawData) {
                data = JSON.parse(rawData);
            }
        } catch (e) {
            console.error(e);
        }


        //needAutoSaveStatus 用来判断是否需要保存
        var needAutoSaveStatus = false;
        setInterval(function () {
            if (needAutoSaveStatus) {

                console.log("触发自动保存");

                var root = graph.save().nodes[0].label;
                var saveIndexData = [];

                localStorage.setItem("auto-save-data", JSON.stringify(graph.save()));
                exportData(); //调用下载自动保存

                app.saveTime = new Date();

                needAutoSaveStatus = false; //更新保存状态
            }
        }, 5000); //5s尝试保存一次


        //1s更新显示保存时间
        setInterval(function () {
            if (app) {
                if (app.saveTime) {
                    if (moment().diff(app.saveTime, 'seconds') < 44) {
                        app.saveTimeShowText = moment().diff(app.saveTime, 'seconds') + "秒前";
                    } else {
                        app.saveTimeShowText = moment(app.saveTime).fromNow();

                    }
                }
            }
        }, 1000)

        data.edges = data.edges.map((edge) => {
            edge.style.endArrow = true
            // edge.style.startArrow = true
            return edge
        })
        console.log(JSON.stringify(data.edges));



        // 使用数据层确保数据的唯一准确性
        var dataLayer = new DataLayer(data);

        dataLayer.on("batch", (commands) => {
            console.log("数据层更新成功", commands)
        })

        // g6操作通知数据层进行数据层数据更新，更新成功后通知g6进行数据更新
        // 考虑到性能，需要将多个操作一起打包
        // 多个操作打包需要考虑到中途可能失败，需要事务失败需要进行回滚，更合理的选择应该是使用数据库

        // 数据层通知g6进行数据更新，一个画布一个监听器实例
        // 直接调用g6进行绘制即可
        // var g6Scheduler = new Scheduler();


        // 不需要对每一个g6实例都建立一个事件监听，虽然也可也把g6理解为事件消费者：数据层告诉g6更新什么数据
        // 如果说存在多个g6实例，展示了不同的数据（都是部分），由数据层告诉g6更新什么数据，g6就是数据消费者
        // 那么将g6实例注册绑定到数据层就是有必要的了
        // 数据层这个词比较抽象，不过数据层依然是没有操作各个g6实例的必要，也没有管理的必要
        // 完全可以在外部建立一个管理的工具，事件机制已经提供实现这个功能必要的基础
        // 数据层只做数据层数据的维护，数据变动的通知。。 至于这些数据是拿去更新其它g6实例还是别的，并没有那么重要

        console.log(dataLayer);

        const graph = new G6.Graph({
            container: 'mountNode',  // String | HTMLElement，必须，容器 id 或容器本身
            width: Math.floor($('#mountNode').width()),              // Number，必须，图的宽度
            height: Math.floor($('#mountNode').height()),             // Number，必须，图的高度
            // renderer: "svg",
            modes: {
                default: [
                    'dblclick-new',
                    'shortcut-keys',
                    'brush-select',
                    'custom-drag-node',
                    'node-click',
                    'drag-canvas',
                    'zoom-canvas',
                    // 边提示框交互工具的配置
                    {
                        type: 'edge-tooltip',
                        formatText(model) {
                            var target = this.graph.findById(model.target).getModel();
                            var source = this.graph.findById(model.source).getModel();

                            const text = `${source.label} ==${model.label || ""}==> ${target.label}`;
                            return text;
                        },
                        shouldUpdate: e => {
                            return true;
                        }
                    }
                ]
            },
            defaultEdge: {
                style: {
                    endArrow: true,
                    lineWidth: 3
                }
            },
            nodeStateStyles: {
                selected: {
                    // hover 状态为 true 时的样式
                    fill: '#d3adf7',
                },
            },
            // layout: {
            //     type: 'force',            // 设置布局算法为 force
            //     linkDistance: 150,        // 设置边长为 100
            //     preventOverlap: true,     // 设置防止重叠
            //     nodeSize: 60,
            //     nodeStrength: 10,
            //     edgeStrength: 3,
            // },  

            // 边在各状态下的样式
            edgeStateStyles: {
                hover: {
                    stroke: '#f00'
                },
                // click 状态为 true 时的样式
                selected: {
                    stroke: '#f00'
                }
            },
            dataLayer: dataLayer, //绑定数据层实例
            animate: true            // Boolean，可选，切换布局时是否使用动画过度
        });


        // 监听鼠标进入节点
        graph.on('node:mouseenter', e => {
            const nodeItem = e.item;
            // 设置目标节点的 hover 状态 为 true
            graph.setItemState(nodeItem, 'hover', true);
        });
        // 监听鼠标离开节点
        graph.on('node:mouseleave', e => {
            const nodeItem = e.item;
            // 设置目标节点的 hover 状态 false
            graph.setItemState(nodeItem, 'hover', false);
        });
        // 监听鼠标进入节点
        graph.on('edge:mouseenter', e => {
            const nodeItem = e.item;
            // 设置目标节点的 hover 状态 为 true
            graph.setItemState(nodeItem, 'hover', true);
        });
        // 监听鼠标离开节点
        graph.on('edge:mouseleave', e => {
            const nodeItem = e.item;
            // 设置目标节点的 hover 状态 false
            graph.setItemState(nodeItem, 'hover', false);
        });

        // 监听鼠标点击边
        graph.on('edge:click', e => {
            // 先将所有当前有 click 状态的边的 click 状态置为 false
            const clickEdges = graph.findAllByState('edge', 'selected');
            clickEdges.forEach(ce => {
                graph.setItemState(ce, 'selected', false);
            });
            const edgeItem = e.item;
            // 设置目标边的 click 状态 为 true
            graph.setItemState(edgeItem, 'selected', true);


            app.currentType = "Edge";
            app.currentItem = edgeItem.getModel();
        });

        //参考antv-2018.alipay.com/zh-cn/g6/3.x/demo/tool/context-menu.html
        graph.on('node:contextmenu', function (evt) {
            console.log();
            $('.menu').css('left', evt.clientX).css('top', evt.clientY).show();


            //设置ID 便于后续操作
            $('.menu a').data('id', evt.item.getModel().id);
        });

        graph.on('node:mouseleave', function (evt) {
            $('.menu').hide();
        });

        // 读取数据和渲染
        graph.data(data);
        graph.render();

        var graphUpdate = _.throttle(function (event, args) {
            console.log("graphUpdate 触发");
            needAutoSaveStatus = true; //需要保存
            if (app) {
                app.$set(app.graphData, 'nodes', graph.save().nodes);
            }
        }, 100, {
            leading: false,
            trailing: true //节流结束后执行
        })

        graph.on("afteradditem", function () { graphUpdate.call(this, 'afteradditem', arguments) })
        graph.on("afterremoveitem", function () { graphUpdate.call(this, 'afterremoveitem', arguments) })
        graph.on("afterupdateitem", function () { graphUpdate.call(this, 'afterupdateitem', arguments) })
    </script>

    <script>


        function relayout(el) {
            var currentNodeId = $(el).data('id');
            var node = graph.findById(currentNodeId);
            // console.log();
            subLayout(node.getModel());
        }
        // 参考g6.antv.vision/zh/examples/net/layoutMechanism#subgraphLayout
        // yuque.com/antv/g6/qopkkg#eYZc6
        function subLayout(centerNode) {

            const data = graph.save(); //最新数据




            const nodes = data.nodes;
            const edges = data.edges;

            const newNodes = []; //被用来参加子图布局计算的节点
            const newEdges = [];
            const newNodeMap = new Map(); //

            //这句不懂 暂时保留
            // fix the nodes[0]
            // nodes[0].fx = nodes[0].x;
            // nodes[0].fy = nodes[0].y;


            //获取选择中的节点

            console.log()

            graph.findAllByState('node', 'selected').forEach(function (node, i) {
                var nodeModel = node.getModel();
                // nodeModel.fx = nodeModel.x;
                // nodeModel.fy = nodeModel.y;

                // nodeModel.x = null;
                // nodeModel.y = null;
                newNodes.push(nodeModel);
                newNodeMap.set(node.getModel().id, i);
            });


            // add the nodes which should be re-layout
            // nodes



            console.log(newNodes, newNodeMap);

            // add related edges
            // 只要有关系都带进来
            edges.forEach(function (edge) {
                const sourceId = edge.source;
                const targetId = edge.target;
                if (newNodeMap.get(sourceId) !== undefined && newNodeMap.get(targetId) !== undefined) {
                    newEdges.push(edge);
                }
            });

            const subForceLayout = new G6.Layout.force({
                center: [centerNode.x, centerNode.y],
                linkDistance: 200,
                preventOverlap: true,
                // nodeSize: 20,
                tick: function tick() {
                    // the tick function to show the animation of layout process
                    graph.refreshPositions();
                }
            });

            //下面布局算法需要手动调用graph.refreshPositions();

            // const subForceLayout = new G6.Layout.radial({
            //     center: [centerNode.x,centerNode.y],
            //     unitRadius: 120,
            //     preventOverlap:false,
            //     nodeSize:200,
            //     nodeSpacing:50,

            // });


            // dagre算法没有中心节点参数指定
            // const subForceLayout = new G6.Layout.dagre({
            //     nodeSize: [40, 20],
            //     nodesep: 1,
            //     ranksep: 1
            // });




            subForceLayout.init({
                nodes: newNodes,
                edges: newEdges
            });
            subForceLayout.execute();

        }


        rule_selected = function (el) {
            var currentNodeId = $(el).data('id');

            //选择该节点的指向节点
            graph.getEdges().forEach(edge => {
                const sourceId = edge.getModel().source;
                const targetId = edge.getModel().target;

                if (sourceId === currentNodeId) {
                    graph.setItemState(targetId, 'selected', true);
                }
            })
        }

        //隐藏edge
        hide = function (el) {
            const clickEdges = graph.findAllByState('edge', 'selected');
            clickEdges.forEach(item => {
                graph.setItemState(item, 'selected', false);

                item.hide();
                graph.updateItem(item, {
                    visible: false, //不可见
                })
                graph.refreshItem(item)

            });
        }
    </script>

    <script>
        var labelFill = {
            word: '#fdf72f',//黄色
            entity: '#9ba0ff',//蓝色
            class: '#ce621d',//橙色
        }
        //代码参考cn.vuejs.org/v2/examples/grid-component.html
        var app = new Vue({
            el: '#app',
            computed: {
                currentEdgeSource: function () {
                    if (this.currentType == "Edge") {
                        return graph.findById(this.currentItem.source).getModel().label
                    }
                },
                currentEdgeTarget() {
                    if (this.currentType == "Edge") {
                        return graph.findById(this.currentItem.target).getModel().label
                    }
                },
                currentItemEdges() {
                    if (this.currentType == "Node") {

                        var data = graph.save();
                        // return graph.findById(this.currentItem.target).getModel().label
                        var result = data.edges.filter((edge) => {
                            const sourceId = edge.source;
                            const targetId = edge.target;

                            if (sourceId === this.currentItem.id || targetId === this.currentItem.id) {
                                return true
                                // graph.setItemState(targetId, 'selected', true);
                            }
                        });

                        result = JSON.parse(JSON.stringify(result));

                        result = result.map(it => {
                            var source = graph.findById(it.source);
                            var target = graph.findById(it.target);
                            it.sourceModel = source.getModel();
                            it.targetModel = target.getModel();
                            return it;
                        })

                        return result;
                    }


                },
                categories() {
                    var categoriesMap = {};

                    // 需要理解computed的原理，推测只要有JSON.stringify的调用就会强制调用，其它情况会根据引用决定
                    //    console.log(JSON.stringify(  graph.save().nodes));

                    this.graphData.nodes.forEach(it => {
                        if (it.category) {
                            if (categoriesMap[it.category] === undefined) {
                                categoriesMap[it.category] = 1
                            } else {
                                categoriesMap[it.category]++
                            }
                        } else {
                            var key = "none";
                            if (categoriesMap[key] === undefined) {
                                categoriesMap[key] = 1
                            } else {
                                categoriesMap[key]++
                            }
                        }
                    });

                    var categories = [];
                    for (var k in categoriesMap) {
                        categories.push({
                            label: k,
                            count: categoriesMap[k]
                        })
                    }
                    return categories;
                },
                listNodes: function () {
                    // console.log("listNodes 更新", JSON.stringify(this.graphData.nodes))
                    // var sortKey = this.sortKey
                    var filterKey = this.filterKey && this.filterKey.toLowerCase()


                    // var order = this.sortOrders[sortKey] || 1
                    var nodes = this.graphData.nodes
                    if (filterKey) {
                        nodes = nodes.filter(function (row) {

                            // console.log(filterKey.)
                            var start = filterKey.indexOf("c:");
                            if (start !== -1) {
                                var filterVal = filterKey.slice(start + 2);

                                if (filterVal == "") {
                                    return true //全部
                                } else if (filterVal == "none") {
                                    return !row.category
                                } else {
                                    return row.category && row.category.toLowerCase().indexOf(filterVal) > -1;
                                }
                            } else {
                                return Object.keys(row).some(function (key) {
                                    return String(row[key]).toLowerCase().indexOf(filterKey) > -1
                                })
                            }
                        })
                    }
                    // if (sortKey) {
                    //     nodes = nodes.slice().sort(function (a, b) {
                    //         a = a[sortKey]
                    //         b = b[sortKey]
                    //         return (a === b ? 0 : a > b ? 1 : -1) * order
                    //     })
                    // }
                    return nodes
                },

            },
            methods: {
                changeEdgeVisible(model, status) {
                    var edge = graph.find('edge', (edge) => {
                        var { source, target } = edge.getModel();
                        return source == model.source && target == model.target
                    })
                    graph.updateItem(edge, {
                        visible: status,
                    })

                    if (status) {
                        edge.show()
                    } else {
                        edge.hide()
                    }

                    graph.refreshItem(edge)
                },
                readerScroll: function (e) {
                    localStorage.setItem('reader-scroll-top', e.target.scrollTop);
                },
                //将属性面板数据更新到图中
                updateItem: function () {

                    if (this.currentType == "Node") {

                        var item = graph.findById(this.currentItem.id);
                        //item.update 不会触发g6事件 改为 graph.updateItem

                        var updateModel = {
                            // id: this.currentItem.id,
                            type: this.currentItem.type, //节点类型
                            description: this.currentItem.description,
                            category: this.currentItem.category,
                            label: this.currentItem.label,
                        };

                        if (this.currentItem.type) {
                            updateModel.style = Object.assign({
                                fill: labelFill[this.currentItem.type]
                            }, updateModel.style)
                        }

                        //显示分类
                        if (this.showCategoryStatus) {
                            updateModel.labelCfg = {
                                style: {
                                    text: `[${updateModel.category}]${updateModel.label}`
                                }
                            }
                        }

                        graph.updateItem(item, updateModel)

                        graph.refreshItem(item)
                    } else {
                        var item = graph.findById(this.currentItem.source);
                        const edges = item.getOutEdges()

                        edges.forEach(edge => {
                            if (edge.getModel().target == this.currentItem.target) {
                                edge.update({
                                    // id: this.currentItem.id,
                                    description: this.currentItem.description,
                                    label: this.currentItem.label
                                });

                                graph.refreshItem(edge)
                            }

                        })

                    }

                },
                getSelection() {




                },
                createSelectedTextNode: function () {
                    if (window.getSelection().toString() == "") {
                        return;
                    }
                    const nodes = graph.findAllByState('node', 'selected');
                    var id = new Date().getTime() + parseInt(Math.random() * 1000).toString();

                    //因为需要手动指定x,y 无法调用布局方法
                    var x = 0, y = 0;
                    if (nodes.length) {
                        x = nodes[0].getModel().x + 100;
                        y = nodes[0].getModel().y;
                    }
                    graph.addItem('node', {
                        id: id,
                        realId: id,
                        label: window.getSelection().toString(),
                        x: x,
                        y: y
                    })

                    if (nodes.length) {
                        graph.addItem('edge', {
                            source: nodes[0].getModel().id,
                            target: id
                        });
                    }

                    // 使用changeData也许要传递xy,如果不传递调用2次后
                    //检测到有节点没有x\y 会导致重新布局 已有位置信息全部丢失

                    //原文标注
                    var html = $("#content").html();
                    // html = html.replace(
                    //     new RegExp(window.getSelection().toString(), 'g'),
                    //     `<span class="highlight" data-id="${id}" onclick="app.focus(this)">${window.getSelection().toString()}</span>`
                    // )

                    html = mark(html,
                        new RegExp(window.getSelection().toString(), 'g'),
                        {
                            html: `<span class="highlight" data-id="${id}" onclick="app.focus(this)">${window.getSelection().toString()}</span>`,
                        }
                    );

                    $("#content").html(html);

                },
                renderVisible() {
                    //隐藏被隐藏的连线
                    graph.getEdges().forEach((edge) => {
                        if (edge.getModel().visible === false) {
                            edge.hide();
                        }
                    })

                    graph.refresh();

                },
                renderReader() {
                    //渲染标注文本
                    var html = localStorage.getItem('reader-text');
                    // console.log(html);
                    var nodes = graph.save().nodes;

                    nodes = nodes.sort((a, b) => {
                        return b.label.length - a.label.length
                    })

                    for (var node of nodes) {
                        var { id, label } = node;
                        if (!label) {
                            continue;
                        }
                        try {

                            html = html.replace(
                                new RegExp(label.replace(/\*/g, "\\\*"), 'g'),
                                `<span class="highlight" data-id="${id}" onclick="app.focus(this)">${label}</span>`
                            )

                            //mark函数存在非常严重的bug

                            // html = mark(html,
                            //     new RegExp(label
                            //         // .replace(/\//g, "\\\/")
                            //         // .replace(/\@/g, "\\\@")
                            //         , 'g'),
                            //     {
                            //         html: `<span class="highlight" data-id="${id}" onclick="app.focus(this)">${label}</span>`,
                            //     }
                            // );
                        } catch (error) {
                            console.error(error)
                        }

                    }

                    this.contentHtml = html;

                    //渲染后更新滚动条位置
                    this.$nextTick(() => {

                        $("#content").unbind("mouseover").unbind("mouseout")
                            .on("mouseover", "span", (e) => {
                                let nodeId = e.target.dataset.id
                                if (nodeId) {
                                    let node = graph.findById(nodeId);
                                    app.hoverNode = node.getModel();
                                    app.hoverX = e.target.clientX;
                                    app.hoverY = e.target.clientY;
                                }
                                // console.log("mouseover", e);
                            }).on("mouseout", "span", (e) => {
                                app.hoverNode = null;
                                app.hoverX = null;
                                app.hoverY = null;
                            })
                        var scrollTop = localStorage.getItem('reader-scroll-top');
                        if (scrollTop) {
                            this.$refs.readerContent.scrollTop = scrollTop
                        }
                    });

                    // $("#content").html(html);

                },
                searchCategory(target) {
                    this.leftTabActive = "节点";
                    var { category } = target.dataset;
                    this.filterKey = "c:" + category;
                },
                showCategory(status) {
                    //是否显示分类。
                    var data = graph.save()

                    data.nodes.forEach((node) => {
                        if (!node.labelCfg) {
                            node.labelCfg = {
                            }
                        }
                        if (!node.labelCfg.style) {
                            node.labelCfg.style = {
                            }
                        }
                        if (status) {
                            if (node.category) {
                                node.labelCfg.style.text = `[${node.category}]${node.label}` //rect
                            } else {
                                delete node.labelCfg.style.text
                            }
                        } else {
                            delete node.labelCfg.style.text
                        }
                    })

                    this.showCategoryStatus = status

                    graph.changeData(data)
                },
                focus: function (target) {
                    console.log(target, this);

                    //参考g6.antv.vision/zh/examples/interaction/position
                    var { id } = target.dataset;

                    var item = graph.findById(id);

                    const selectedNodes = graph.findAllByState('node', 'selected');
                    selectedNodes.forEach(cn => {
                        graph.setItemState(cn, 'selected', false);
                    });


                    graph.setItemState(item, 'selected', true);

                    this.currentType = "Node";
                    this.currentItem = item.getModel();
                    // const item = event.item;
                    // 聚焦当前点击的节点（把节点放到视口中心）

                    const matrix = item.get('group').getMatrix();
                    const point = {
                        x: matrix[6],
                        y: matrix[7]
                    };
                    const width = graph.get('width');
                    const height = graph.get('height');
                    // 找到视口中心
                    const viewCenter = {
                        x: width / 2,
                        y: height / 2
                    };
                    const modelCenter = graph.getPointByCanvas(viewCenter.x, viewCenter.y);
                    const viewportMatrix = graph.get('group').getMatrix();
                    // 画布平移的目标位置，最终目标是graph.translate(dx, dy);
                    const dx = (modelCenter.x - point.x) * viewportMatrix[0];
                    const dy = (modelCenter.y - point.y) * viewportMatrix[4];
                    let lastX = 0;
                    let lastY = 0;
                    let newX = void 0;
                    let newY = void 0;
                    // 动画每次平移一点，直到目标位置
                    graph.get('canvas').animate({
                        onFrame: function onFrame(ratio) {
                            newX = dx * ratio;
                            newY = dy * ratio;
                            graph.translate(newX - lastX, newY - lastY);
                            lastX = newX;
                            lastY = newY;
                        }
                    }, 300, 'easeCubic');

                    console.log(this, id)
                },
                renderTypeStyle() {
                    var data = graph.save()
                    data.nodes = data.nodes.map((node) => {
                        if (node.type) {
                            node.style = Object.assign({}, node.style, {
                                fill: labelFill[node.type]
                            })
                        }
                        return node
                    })

                    graph.changeData(data);
                },
            },
            created() {
                this.renderTypeStyle();//渲染Type颜色
                this.renderVisible();
                this.renderReader();
            },
            data: {
                contentHtml: '',
                currentType: '', //Node、Edge
                currentItem: {},
                leftTabActive: "节点", //leftTab默认激活选项卡
                rightTabActve: "属性",//rightTab默认激活选项卡
                hoverNode: null,//阅读器悬浮节点
                hoverX: 0,
                hoverY: 0,
                showReader: true,
                showSearch: true,
                showAttr: true,
                showCategoryStatus: false, //label显示分类
                filterKey: "",
                saveTime: "", //自动保存时间
                saveTimeShowText: "无", //保存时间显示
                graphData: graph.save(),
                // nodes: graph.save().nodes,
            }
        })

    </script>
</body>

</html>